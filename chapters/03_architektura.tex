\chapter{Architektura kódu}
Před zahájením implementace je důležité si rozmyslet a naplánovat architekturu kódu.
Dobře navržená architektura nám může ušetřit spoustu času a námahy v budoucnu, například při přidávání nových funkcí nebo opravování stávajícího kódu.
Zároveň přispívá ke zvýšení jeho čitelnosti a udržovatelnosti.
Naopak špatně navržená architektura může vést k problémům, jako je těžko udržovatelný kód, složitá rozšiřitelnost, náročné zjišťování chyb a celkově pomalejší vývoj.

Architektura aplikace byla navržena především s cílem jasně oddělit odpovědnosti jednotlivých částí kódu, čímž podporuje dosažení výše uvedených vlastností.
Při návrhu byly převzaty vybrané principy běžně používané v moderních architektonických přístupech, které jsou popsány v následujících podkapitolách.


\section{Architektonický vzor MVVM}
Jako základní architektonický vzor byla zvolena architektura Model-View-ViewModel (MVVM).\footfullcite{mvvm}
Je to doporučený vzor pro vývoj nativních Android aplikací, který je podporován samotným Android Frameworkem a prosazován společností Google, která stojí za vývojem platformy Android.\footfullcite{android_recommended_architecture}
V navrhované aplikaci je architektonický vzor MVVM využit k jasnému oddělení odpovědností mezi uživatelským rozhraním, logikou obrazovek a doménovou logikou.
Vzor MVVM za tímto účelem rozděluje aplikaci do tří hlavních komponent: Model, View a ViewModel.

\textbf{View} představuje uživatelské rozhraní a je zodpovědné pouze za zobrazování dat a předávání uživatelských událostí.
V této aplikaci je View realizováno pomocí frameworku Jetpack Compose a neobsahuje žádnou aplikační ani doménovou logiku, jak je doporučeno v architektonickém vzoru MVVM\@.

\textbf{Model} reprezentuje data a doménovou logiku aplikace, včetně komunikace s repozitáři a datovými zdroji.
Podle MVVM nesmí být nijak závislý na uživatelském rozhraní ani jeho konkrétní implementaci a nesmí obsahovat logiku týkající se zobrazení.
V navrhované aplikaci tuto roli plní doménová vrstva, jejíž struktura a principy jsou podrobně popsány v sekci~\ref{sec:oddeleni-domenove-a-datove-vrstvy}.

\textbf{ViewModel} slouží jako prostředník mezi View a Modelem.
Je zodpovědný za správu stavu uživatelského rozhraní, reakci na uživatelské události a komunikaci s Modelem za účelem získání nebo aktualizace dat.

ViewModel obsahuje aktuální stav zobrazení a vystavuje ho ve formě, kterou může View snadno sledovat a reagovat na jeho změny.
V navrhované aplikaci jsou pro správu stavu obrazovek využívány asynchronní datové toky (Flow), do kterých při změně dat ViewModel publikuje nový stav jakožto neměnný (immutable\footfullcite{compose_ui_architecture}) objekt.
View pak tento stav pozoruje a na jeho základě vykresluje uživatelské rozhraní.
Naopak View zase předává uživatelské události ViewModelu, který na ně reaguje a případně aktualizuje stav nebo komunikuje s Modelem.
Tomuto přístupu se říká \textbf{jednosměrný tok dat} (unidirectional data flow\footfullcite{android_recommended_architecture}) a přispívá k lepší předvídatelnosti a stabilitě aplikace.

Ve ViewModelu se nachází pouze logika týkající se uživatelského rozhraní, ne však jeho samotné vykreslování.
Doménová logika a správa dat jsou plně odděleny v Modelu.
Stejně tak logika spojená s navigací mezi obrazovkami, zobrazení vyskakovacích oken či upozornění pro uživatele se nachází ve View, protože je závislá na konkrétní implementaci uživatelského rozhraní.

ViewModely v této aplikaci nevykonávají žádné přímé akce nad uživatelským rozhraním, ale vystavují takzvané \textbf{efekty} (side-effects\footfullcite{android_side_effect}).
Efekty jsou jednorázové události, které vyvolávají akce v uživatelském rozhraní, jako například právě zmíněná navigace nebo zobrazení vyskakovacích oken.
View vystavované efekty interpretuje a na jejich základě provádí příslušné akce v uživatelském rozhraní.

Jak bylo zmíněno výše, MVVM je přímo podporovaný Android Frameworkem.
ViewModely jsou v Android Frameworku takzvaně lifecycle-aware, což znamená, že automaticky reagují na změny životního cyklu aplikace, například při změně konfigurace zařízení (otočení obrazovky) nebo při přechodu aplikace na pozadí.
Díky tomu nedochází ke ztrátě stavu uživatelského rozhraní a k opakovanému načítání dat při těchto změnách.

Zvolený způsob využití architektonického vzoru MVVM se v praxi osvědčil jako přehledný a umožnil jasné oddělení uživatelského rozhraní od doménové logiky aplikace.


\section{Struktura projektu podle funkčních celků}
% *Feature-based struktura projektu*

% každá feature obsahuje:
% - domain
% - data
% - případně di

% konkrétní features (+ vysvětlení):
% - auth
% - core - DomainResult (viz. \ref{sec:domain_result}), ...
% - common
% - shop, review, user, ...
% - ui - dle obrazovek/samostatných celků

% Zdůraznit přínos:
% - lepší orientace v kódu
% - omezení provázanosti
% - možnost paralelního vývoje (možnost kompletně přepsat jednu feature bez vlivu na ostatní)


\section{Oddělení doménové a datové vrstvy}\label{sec:oddeleni-domenove-a-datove-vrstvy}

% Domain
%  - doménové modely
%  - use case třídy
%  - rozhraní repozitářů
% "Komunikace s backendem probíhá přes rozhraní definovaná v doménové vrstvě."

% Data
%  - implementace repozitářů
%  - datové modely
%  - práce s Firestore, Firebase Auth, Firebase Storage, ...

% "Rozhraní repozitářů jsou definována v doménové vrstvě, zatímco jejich konkrétní implementace se nachází v datové vrstvě."
% "Doménová logika je tak nezávislá na konkrétním způsobu ukládání nebo získávání dat."


\section{Zpracování výsledků a chyb v doménové vrstvě}
% DomainResult a DomainError
% princip...
% výhody...

% Zdůrazni:
%  - návratová hodnota use-casů a repozitářů
%  - nutí volajícího explicitně řešit chyby


\section{Tok dat v aplikaci}

% příklad toku dat:
% 1. uživatelská akce v UI
% 2. ViewModel zpracuje událost
% 3. volání use-casu, doménová logika
% 4. volání repozitáře
% 5. výsledek jako DomainResult z repozitáře (respektive DomainError v případě chyby)
% 6. aktualizace StateFlow (respektive zpracování chyby)
% 7. UI se automaticky přerenderuje

% zmínit immutabilty princip?


\section{Vkládání závislostí (Dependency Injection)}
% Hilt
% výhody DI
%  - lepší testovatelnost
%  - méně kódu pro vytváření závislostí
%  - pro viewmodely, use-casy, repozitáře


\section{Shrnutí architektury}
% architektura odpovídá rozsahu bakalářské práce
% ověřena reálným provozem aplikace
% umožnila úspěšnou implementaci a publikaci aplikace
% zjednodušila vývoj, údržbu kódu, přidávání nových funkcí a opravy chyb
%
% "Zvolená architektura se v praxi osvědčila jako přehledná, rozšiřitelná a vhodná pro další rozvoj aplikace."
